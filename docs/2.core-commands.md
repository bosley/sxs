# Core Commands

The core commands are the commands that the main C++ interpreters understand. These commands are broken down into two primary categories: `datum` commands and `instruction` commands. A datum command is any symbol or list that is prefixed with a `#` symbol. Other than this prefix there is no difference in form between datum commands and instruction commands. 

## SLP

SLP is the "simple language protocol" or "small list processor." It really doesn't matter. Conceptually "s-expression small/limited lists parsing/processing."

Its just an implementation of the homomorphic instruction notiation common in s-expression languages. SLP is not a language, just an implementation of a parser that parses the following forms:

*Forms*:
```
; comment
()
[]
{}
"double-quote list aka string"
0.00
0
symbol
```

*Types*

- paren list `()`
- bracket list `[]`
- brace list `{}`
- string `"..."`
- real `0.00`
- integer `0`
- symbol `symbol`

*Variants*:

The forms appearing as defined above is the *standard* variant of data. 

SLP defines variants as "any datum prefixed directly by a variant identifier" where the variant identifers categorize the dataum into its respective category:

- `'` quoted category
- `#` datum category
- `?` aberrant category
- `@` error category

Examples:

```lisp

'(1 2 3)

; See how we made the entire () as the error category
#(1 2 @(this is an error object) 4)

```

# SXS SLP Interpretations

- `standard`: No identifier, what we consider something to "evaluate" given a context
- `quoted`: Defers processing, as is common is s-expr languages. Every eval, one quote is removed.
- `datum`: Directed to "meta" processor for loading instructions and runtime modifications
- `aberrant`: Leveraged by sxs runtime to create/ track complex runtime objects (lambdas). 
- `error`: Any _type_ in this category is not considered by the runtime as anything special. Errors at the data/instruction level are meant to be handled by the programmer; the runtime does not care

# Types

SXS leverages SLP types directly with additional semantic meaning assigned by the interpreter. All types are represented in the underlying SLP binary format.

## Core Types

| Type Symbol | Example | Description |
|-------------|---------|-------------|
| `:none` | n/a | Empty/no value |
| `:int` | `42` `-123` | 64-bit signed integers |
| `:real` | `3.14` `-0.5` | 64-bit floating point |
| `:rune` | n/a | Single character - implicitly created as member of string or via kernel (parser cannot directly parse runes as symbols take precedence) |
| `:symbol` | `hello` `my-var` | Symbolic identifiers |
| `:str` | `"hello world"` | String literals (DQ_LIST) |

## List Types

| Type Symbol | Form | Description |
|-------------|------|-------------|
| `:list` or `:list-p` | `()` | Paren list - standard evaluation form |
| `:list-b` | `[]` | Bracket list - sequential operations |
| `:list-c` | `{}` | Brace list - data collections |

## Special Types

| Type Symbol | Example | Description |
|-------------|---------|-------------|
| `:aberrant` | `?lambda-id` | Runtime aberrants (lambdas, complex objects) |
| `:error` | `@(error message)` | Error category objects |
| `:some` | `'(data)` | Quoted/wrapped data |
| `:datum` | `#(command)` | Datum commands |

## Variadic Type Annotations

All type symbols support a variadic form by appending `..` to the type name. This indicates the parameter can accept multiple values of that type.

Examples:
- `:int..` - variadic integer parameters
- `:str..` - variadic string parameters  
- `:list..` - variadic list parameters
- `:any..` - variadic parameters of any type

This is particularly useful when defining functions that accept a variable number of arguments:

```lisp
(def sum (fn (values :int..) :int [
    ; function body that processes variadic integers
]))
```

# Exceptions

SXS provides two mechanisms for handling errors:

1. **Error Objects** (`@`): Error category data that can be passed around and inspected by the programmer. The runtime does not treat these specially - they are user-managed.

2. **Runtime Exceptions**: C++ exceptions thrown during execution. These can be caught using `recover` blocks.

## Datum Commands

Datum commands are meta-instructions prefixed with `#` that control the runtime environment. They **must** appear at the start of a program, before any regular instructions. Once the first non-datum instruction executes, datum commands are locked and cannot be used again.

| Command | Syntax | Description |
|---------|--------|-------------|
| `load` | `#(load "kernel-name" ...)` | Load one or more kernel libraries. Each kernel name is searched in include paths. |
| `import` | `#(import symbol "path" ...)` | Import file(s) and bind to symbol(s). Takes pairs of symbol and file path. |

### Examples

```lisp
#(load "io" "kv" "random")
#(import utils "lib/utils.sxs")
#(import math "lib/math.sxs" strings "lib/strings.sxs")
```

## Instruction Commands

Instruction commands are the core language constructs evaluated by the interpreter. These form the basis of SXS programs.

### Variable Definition

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `def` | `(def symbol value)` | `:none` | Define symbol in current scope. Errors if symbol already exists in current scope. |
| `export` | `(export symbol value)` | `:none` | Define and export symbol from imported file. Only valid in imported files. |

### Functions

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `fn` | `(fn (params...) :return-type [body])` | `:aberrant` | Create lambda. Params are `name :type` pairs. Body is bracket list. |
| `apply` | `(apply lambda {args})` | `:aberrant` | Apply lambda to brace list of arguments. |

### Control Flow

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `if` | `(if condition true-branch false-branch)` | `:aberrant` | Conditional execution. Condition is truthy if non-zero integer. |
| `match` | `(match value (pattern result)...)` | `:aberrant` | Pattern matching on values. Lambdas match by identity (same lambda ID). Returns result of first matching pattern or `@(no matching handler found)`. |
| `reflect` | `(reflect value (:type body)...)` | `:aberrant` | Type-based dispatch. Lambdas can be matched using signature syntax `:fn<param_types>return_type`. Evaluates body for matching type or returns `@(handler not supplied for given type)`. |
| `do` | `(do [body])` | `:aberrant` | Execute body in loop until `done` is called. Injects `$iterations` symbol (int, starts at 1). Nested loops supported. |
| `done` | `(done value)` | `:none` | Exit current `do` loop with evaluated value. Must be called inside a `do` loop. |

### Type Operations

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `cast` | `(cast :type value)` | `:aberrant` | Convert value to target type. Supports numeric conversions (int/real) and list type conversions (including string/bytes). |

### List Operations

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `at` | `(at index collection)` | `:aberrant` | Access element at index from list or string. Index must be non-negative integer. For strings, returns integer byte value. Returns `@(index out of bounds)` if index is invalid. |

### Error Handling

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `try` | `(try body handler)` | `:aberrant` | Handle error objects. If body returns `:error` type, evaluate handler with `$error` bound to inner object. |
| `recover` | `(recover [body] [handler])` | `:aberrant` | Catch runtime exceptions. Handler has `$exception` bound to exception message string. |
| `assert` | `(assert condition message)` | `:none` | Throw exception if condition is zero. Message must be string. |

### Metaprogramming

| Command | Syntax | Return | Description |
|---------|--------|--------|-------------|
| `eval` | `(eval code-string)` | `:aberrant` | Parse and evaluate string as code in new scope. |
| `debug` | `(debug values...)` | `:int` | Print debug output to stdout. Variadic. |

### Examples

```lisp
(def add (fn (a :int b :int) :int [(alu/add a b)]))

(def result (if (alu/gt x 0) 
    (debug "positive")
    (debug "non-positive")))

(match value
    (0 "zero")
    (1 "one")
    (2 "two"))

(def add (fn (a :int b :int) :int [42]))
(def mul (fn (x :int y :int) :int [100]))
(match add
    (mul "different lambda")
    (add "same lambda identity!"))

(reflect data
    (:int (debug "got integer"))
    (:str (debug "got string")))

(reflect add
    (:fn<int,int>int (debug "int->int function"))
    (:fn<str,str>str (debug "str->str function")))

(recover
    [(assert (alu/gt x 0) "x must be positive")]
    [(debug "assertion failed:" $exception)])

(try (some-operation)
    (debug "error occurred:" $error))

(def result (do [
    (debug "Iteration:" $iterations)
    (done $iterations)
]))

(def nested (do [
    (def inner (do [
        (done 100)
    ]))
    (done inner)
]))

(def x (cast :real 42))
(def bytes (cast :str {65 66 67}))

(def first (at 0 {1 2 3}))
(def char-code (at 0 "ABC"))
(def result (at 5 {1 2 3}))
```

## Design Philosophy

The core interpreter is intentionally minimal and is not expected to grow significantly. The commands documented above represent the fundamental building blocks needed for language semantics: variable binding, function definition, control flow, type dispatch, and error handling.

Additional functionality is intended to be provided through the kernel system rather than as core commands. This modular approach allows:

- **Separation of concerns**: Core language semantics remain stable while functionality evolves
- **Selective loading**: Programs only load the kernels they need
- **Interoperability**: Kernels can interoperate with each other and with imported SXS modules
- **Extensibility**: New capabilities can be added without modifying the interpreter

The standard kernel set (`libs/std/`) provides common functionality that would traditionally be part of a standard library:

- **io**: File operations, console I/O
- **alu**: Arithmetic and logic operations
- **kv**: Key-value data structures
- **random**: Random number generation

For most practical programs, the combination of core commands and standard kernels provides everything needed. Custom kernels can be created for domain-specific requirements.