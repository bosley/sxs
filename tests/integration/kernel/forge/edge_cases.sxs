[
    #(load "forge" "io")

    (io/put "=== Forge Edge Cases Test ===\n")

    (io/put "\n--- Operations on empty lists ---\n")
    (def e '())
    (def e1 (forge/pf e 1))
    (def e2 (forge/pb e 1))
    (def e3 (forge/rf e))
    (def e4 (forge/rb e))
    (def e5 (forge/rev e))
    (def e6 (forge/count e))
    (assert (eq (forge/count e1) 1) "Push front to empty should have 1 element")
    (def e1_list (cast :list-p e1))
    (assert (eq (at 0 e1_list) 1) "Element should be 1")
    (assert (eq (forge/count e2) 1) "Push back to empty should have 1 element")
    (def e2_list (cast :list-p e2))
    (assert (eq (at 0 e2_list) 1) "Element should be 1")
    (assert (eq (forge/count e3) 0) "Remove front from empty should stay empty")
    (assert (eq (forge/count e4) 0) "Remove back from empty should stay empty")
    (assert (eq (forge/count e5) 0) "Reverse empty should stay empty")
    (assert (eq e6 0) "Count of empty should be 0")
    (io/put "Push front to empty: OK\n")
    (io/put "Push back to empty: OK\n")
    (io/put "Remove front from empty: OK\n")
    (io/put "Remove back from empty: OK\n")
    (io/put "Reverse empty: OK\n")
    (io/put "Count empty: %d\n" e6)

    (io/put "\n--- Operations on single element ---\n")
    (def s '(42))
    (def s1 (forge/rf s))
    (def s2 (forge/rb s))
    (def s3 (forge/rev s))
    (def s4 (forge/rotr s 1))
    (def s5 (forge/rotl s 1))
    (assert (eq (forge/count s1) 0) "Remove front from single should be empty")
    (assert (eq (forge/count s2) 0) "Remove back from single should be empty")
    (assert (eq (forge/count s3) 1) "Reverse single should still have 1")
    (def s3_list (cast :list-p s3))
    (assert (eq (at 0 s3_list) 42) "Element should be 42")
    (assert (eq (forge/count s4) 1) "Rotate single should still have 1")
    (def s4_list (cast :list-p s4))
    (assert (eq (at 0 s4_list) 42) "Element should be 42")
    (assert (eq (forge/count s5) 1) "Rotate single should still have 1")
    (def s5_list (cast :list-p s5))
    (assert (eq (at 0 s5_list) 42) "Element should be 42")
    (io/put "Remove front from single element\n")
    (io/put "Remove back from single element\n")
    (io/put "Reverse single element\n")
    (io/put "Rotate single element\n")

    (io/put "\n--- Upcast scalar to list ---\n")
    (def scalar 99)
    (def sc1 (forge/count scalar))
    (def sc2 (forge/pf scalar 1))
    (def sc3 (forge/pb scalar 2))
    (assert (eq sc1 1) "Scalar count should be 1")
    (assert (eq (forge/count sc2) 2) "Push front to scalar should give 2 elements")
    (def sc2_list (cast :list-p sc2))
    (assert (eq (at 0 sc2_list) 1) "First should be 1")
    (assert (eq (at 1 sc2_list) 99) "Second should be 99")
    (assert (eq (forge/count sc3) 2) "Push back to scalar should give 2 elements")
    (def sc3_list (cast :list-p sc3))
    (assert (eq (at 0 sc3_list) 99) "First should be 99")
    (assert (eq (at 1 sc3_list) 2) "Second should be 2")
    (io/put "Count scalar (upcast): %d\n" sc1)
    (io/put "Push front to scalar: OK\n")
    (io/put "Push back to scalar: OK\n")

    (io/put "\n--- Large rotations ---\n")
    (def x '(1 2 3))
    (def x1 (forge/rotr x 100))
    (def x2 (forge/rotl x 100))
    (assert (eq (forge/count x1) 3) "Large rotation should preserve size")
    (def x1_list (cast :list-p x1))
    (assert (eq (at 0 x1_list) 3) "First element after large rotr should be 3")
    (assert (eq (forge/count x2) 3) "Large rotation should preserve size")
    (def x2_list (cast :list-p x2))
    (assert (eq (at 0 x2_list) 2) "First element after large rotl")
    (io/put "Rotate by value > length: OK\n")

    (io/put "\n--- Negative shifts/rotations ---\n")
    (def y '(1 2 3 4 5))
    (def y1 (forge/lsh y -1))
    (def y2 (forge/rotr y -1))
    (assert (eq (forge/count y1) 5) "Negative shift should be no-op")
    (def y1_list (cast :list-p y1))
    (assert (eq (at 0 y1_list) 1) "First should be 1")
    (assert (eq (forge/count y2) 5) "Negative rotate should be no-op")
    (def y2_list (cast :list-p y2))
    (assert (eq (at 0 y2_list) 1) "First should be 1")
    (io/put "Negative count treated as no-op\n")

    (io/put "\n=== All edge case tests complete ===\n")
]
